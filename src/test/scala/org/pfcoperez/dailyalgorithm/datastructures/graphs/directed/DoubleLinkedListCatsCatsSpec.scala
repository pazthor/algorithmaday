package org.pfcoperez.dailyalgorithm.datastructures.graphs.directed

import org.scalatest.{FlatSpec, Inside, Matchers}

class DoubleLinkedListCatsCatsSpec extends FlatSpec with Matchers with Inside {

  import DoubleLinkedListCats.syntax._
  import DoubleLinkedListCats.{lastNode, Empty => DlEmpty, Node => DlNode}

  def toListLeftToRight[T](dl: DoubleLinkedListCats[T], acc: List[T] = Nil): List[T] = dl match {
    case DlEmpty => acc
    case DlNode(_, v, right) => toListLeftToRight(right.value, acc :+ v)
  }

  def toListRightToLeft[T](dl: DoubleLinkedListCats[T]): List[T] = {
    def toListFromLast(dl: DoubleLinkedListCats[T], acc: List[T]): List[T] = dl match {
      case DlEmpty => acc
      case DlNode(left, v, _) => toListFromLast(left.value, v :: acc)
    }
    toListFromLast(lastNode(dl), Nil)
  }

  val elements = 1 to 10

  "An double linked list" should "allow to be generated by appending elements" in {

    val lAppending = ((DlEmpty : DoubleLinkedListCats[Int]) /: elements) { (acc, element) =>
      acc :+ element
    }

    toListLeftToRight(lAppending) shouldBe elements.toList

  }

  it should "allow to be generated by prepending elements" in {

    val lPrepending = (elements :\ (DlEmpty : DoubleLinkedListCats[Int])) { (element, acc) =>
      element +: acc
    }

    toListLeftToRight(lPrepending) shouldBe elements.toList

  }

  it should "allow to move over it in both directions" in {

    val l = (elements :\ (DlEmpty : DoubleLinkedListCats[Int])) { (element, acc) =>
      element +: acc
    }

    l.right.right.right.left.headOption shouldBe Some(3)

    lastNode(l).left.right.right.headOption shouldBe None
    lastNode(l).left.right.headOption shouldBe Some(10)

  }

}
